<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Mapping with Python</title>
	<link rel="stylesheet" type="text/css" href="styles/styles.css">
	<link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
</head>

<body>
	<div class="navigation">
		<ul>
			<li class="active"><a href="#Casey">Home</a></li>
			<li><a href="#course">Philosophy</a></li>
			<li><a href="#course">Custom Milling</a></li>
			<li><a href="#hire-me">Blog</a></li>
		</ul>
	</div>

	<h1>Mapping with Python</h1>
	<img src="images\SouthAmericaCropped.png" height="400">
	<p>This page outlines the pythonic solution I developed when I had to make several maps of the same spatial domain but with different data. I typically use QGIS and GRASS GIS but the process to output a final map is slow and tedious when producing 50 maps. With what we cover here, the same task can be completed in moments.</p>

	<ol>
		<li>Environment</li><br>
			<p>The first thing to address is the environment. I like to use Anaconda which makes this task quite straightforward. To create a new environment, navigate to where you want your project to "live". Then open a command prompt (I prefer <a href="https://cmder.net/">cmder</a>) and enter...</p>

			<p class="cmd">conda create --name <i>YourEnvironmentName</i> python=3.6</p>
		
			<p>This will usually take a little while to complete and it may ask if you would like to proceed. Enter 'y' to indicate you would like to proceed and once it has finished, you can activate the environment.</p>

			<p class="cmd">activate <i>YourEnvironmentName</i></p>
			
			<p>This should activate your environment. You can tell because the cursor should have <i>YourEnvironmentName</i> in front of it. Note that sometimes you have to (or you can) use <p class="cmd">conda activate <i>YourEnvironmentName</i></p> 

			<p>You will have to install some packages. They can be installed using pip or conda. Conda tends to be more effective. </p>

			<p class="cmd">conda install basemap</p>
			
			<p>And that should get us set up for mapping! If you have any trouble with installation, feel free to reach out and I will try to help. I have done this with both a Python 2.7 and 3.6 environment. </p>

		<li>Imports</li><br>

			<p>Now let's get into it! I am a scripter so I will just go through my script piece by piece. I like to start with all of my imports so that I have it when I need it. I will continue to display text intended to be code with the command line style formatting so as to be clear about what is code and what is explanation.</p>

			<p class="cmd">from mpl_toolkits.basemap import Basemap, pyproj <br>
			import matplotlib.pyplot as plt <br>
			from matplotlib.patches import Polygon <br>
			from pylab import * <br>
			import os <br>
			import glob <br></p>

		<li>Functions</li> <br>
			<p>Next I like to import my functions. Again, this is advantageous because it can be called anytime afterward. Some of these are pretty straightforward. Some are just part of how I code. Others are very specific to the task at hand, mapping. I'll point out and explain what they are each for.</p>

			<p class="cmd"># Define last position finder <br>
			def find_last(s,t): <br>
			&nbsp;&nbsp;&nbsp;last_pos = -1 <br>
			&nbsp;&nbsp;&nbsp;while True: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos = s.find(t, last_pos +1) <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pos == -1: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return last_pos <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_pos = pos</p>

			<p>This is a pretty simple function that I mainly use to navigate the path variable. I will usually call the relative path to my script and then, because I use a convention of keeping my Python files in a \Python folder for projects, I need to get out of that folder in my path to access other files. Hopefully that makes more sense for you shortly. Next is something that I mostly use for legends. If you just want to bang out maps and don't care about legends, don't worry about this.</p>

			<p class="cmd">def drawRect(x1,y1,x,y, color, width):<br>
			&nbsp;&nbsp;&nbsp;poly = Polygon([[x1,y1], [x1+x,y1], [x1+x,y1+y], [x1,y1+y]], facecolor='w', edgecolor=color, linewidth=width)<br>
			&nbsp;&nbsp;&nbsp;plt.gca().add_patch(poly)<br></p>

			<p>This is a quite simple function that just takes in the coordinates of the bottom left corner of the box (x1,y1), the dimensions in either direction (x,y), the background color (color) and a variable to help scale the overall width to help in the event that the text is longer than the x dimension (width*).</p>

			<p>This next one is definitely longer and it is more involved but it is not very complicated. I will first present it all and then break down the peices. To help digest it before you even look, it is one class with three functions within it. See if you can differentiate those functions.</p>

			<p class="cmd"># add drawscale method to Basemap class. <br>
			class Basemap2(Basemap): <br>
			&nbsp;def drawscale(self,length, yoffset=None): <br>
			&nbsp;&nbsp;"""draw a simple map scale from x1,y to x2,y in map projection  <br>
			&nbsp;&nbsp;coordinates, label it with actual distance in km"""  <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Define dimensions <br>
			&nbsp;&nbsp;x1,y1,x2,y,extra = 0.03*map.xmax, 0.03*map.xmax, 0.03*map.xmax+length, 0.05*map.xmax, 0.01*map.xmax <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Call rectangle function for bounding box <br>
			&nbsp;&nbsp;drawRect(x1-extra,y1-extra,length+2*extra+1300,y1+2*extra, 'k', 1) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Get info for scale bar <br>
			&nbsp;&nbsp;yoffset = 0.01*map.ymax <br>
			&nbsp;&nbsp;lon1,lat1 = self(x1,y,inverse=True)  <br>
			&nbsp;&nbsp;lon2,lat2 = self(x2,y,inverse=True)  <br>
			&nbsp;&nbsp;# Convert to map projection units <br>
			&nbsp;&nbsp;gc = pyproj.Geod(a=self.rmajor,b=self.rminor)  <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# This gets the distance on a level plane (inv), to get distance on the plane, use sqrt() <br>
			&nbsp;&nbsp;az12,az21,dist = gc.inv(lon1,lat1,lon2,lat2) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# These are the pieces of the scale bar <br>
			&nbsp;&nbsp;map.plot([x1,x2],[y,y],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;# Vertical ticks <br>
			&nbsp;&nbsp;map.plot([x1,x1],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;map.plot([x1+length/6.0,x1+length/6.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;map.plot([x1+length/3.0,x1+length/3.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;map.plot([x1+2*length/3.0,x1+2*+length/3.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;map.plot([x2,x2],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
			&nbsp;&nbsp;# Label after converting to miles <br>
			&nbsp;&nbsp;# 0 <br>
			&nbsp;&nbsp;text(x1,y-yoffset-0.5*extra,'%d' % (dist*0*0.621371,), <br>
			&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
			&nbsp;&nbsp;# 0.5 <br>
			&nbsp;&nbsp;text(x1+length/6.0,y-yoffset-0.5*extra,'%g' % (round(dist/6/1000.*0.621371,1),), <br>
			&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
			&nbsp;&nbsp;# 1 <br>
			&nbsp;&nbsp;text(x1+length/3.0,y-yoffset-0.5*extra,'%d' % (dist/3/1000.*0.621371,), <br>
			&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
			&nbsp;&nbsp;# 2 <br>
			&nbsp;&nbsp;text(x1+length*2/3.0,y-yoffset-0.5*extra,'%d' % (dist*2/3/1000.*0.621371,), <br>
			&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
			&nbsp;&nbsp;# 3 <br>
			&nbsp;&nbsp;text(x1-200+length,y-yoffset-0.5*extra,'%d miles' % (dist/1000.*0.621371,), <br>
			&nbsp;&nbsp;verticalalignment='top', horizontalalignment='left',fontsize=9, color= 'k', fontweight='normal')  <br>
 <br>
			&nbsp;def drawLegend(self,y1, yoffset=None): <br>
			&nbsp;&nbsp;# Define dimensions <br>
			&nbsp;&nbsp;x1 = 0.03*map.xmax <br>
			&nbsp;&nbsp;extra = 0.01*map.xmax <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Make a list of items <br>
			&nbsp;&nbsp;Items = ['LANL Boundary', 'Quotient <= 1', 'Quotient > 1'] <br>
			&nbsp;&nbsp;Markers = ['rectangle', 'lime', 'r'] <br>
			&nbsp;&nbsp;markerColor = ['k', 'orangered', 'lime'] <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Define height and width <br>
			&nbsp;&nbsp;vertLineSpace = 1000 <br>
			&nbsp;&nbsp;vertSpace = vertLineSpace*len(Items)+100 <br>
			&nbsp;&nbsp;horSpace = max([len(item) for item in Items])*550 <br>
			&nbsp;&nbsp;symbolSpace = 1500 <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Call rectangle function for bounding box <br>
			&nbsp;&nbsp;drawRect(x1-extra,y1,horSpace,vertSpace, 'k',1) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Populate legend <br>
			&nbsp;&nbsp;j = 0 <br>
			&nbsp;&nbsp;for item in Items: <br>
			&nbsp;&nbsp;&nbsp;# Write text <br>
			&nbsp;&nbsp;&nbsp;text(x1+symbolSpace,y1+0.75*vertLineSpace+j*vertLineSpace, item, <br>
			&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='left',fontsize=11, color= 'k', fontweight='normal')  <br>
			&nbsp;&nbsp;&nbsp; <br>
			&nbsp;&nbsp;&nbsp;# Draw symbols <br>
			&nbsp;&nbsp;&nbsp;if Markers[j] == 'rectangle': <br>
			&nbsp;&nbsp;&nbsp;&nbsp;drawRect(x1+0.25*symbolSpace,y1+0.25*vertLineSpace+j*vertLineSpace,0.5*symbolSpace, 0.5*vertLineSpace, markerColor[j],1.5) <br>
			&nbsp;&nbsp;&nbsp;else: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;map.plot(x1+0.5*symbolSpace,y1+0.5*vertLineSpace+j*vertLineSpace,  <br>
			&nbsp;&nbsp;&nbsp;&nbsp;marker='o', color = Markers[j], markersize=5, markeredgewidth=1) <br>
			&nbsp;&nbsp;&nbsp;j = j + 1 <br>

			&nbsp;def northArrow(self): <br>
			&nbsp;&nbsp;# Define dimensions <br>
			&nbsp;&nbsp;x1,y1 = 0.97*map.xmax, 0.03*map.xmax <br>
			&nbsp;&nbsp;x,y,extra = 3000, 4000, 0.01*map.xmax <br>
			&nbsp;&nbsp;inset = 600 <br>
			&nbsp;&nbsp;rOut = 800 <br>
			&nbsp;&nbsp;rIn = 650 <br>
			&nbsp;&nbsp;xy = (x1-inset,y1+inset) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Make circles <br>
			&nbsp;&nbsp;circleOut = matplotlib.patches.CirclePolygon(xy, radius=rOut, facecolor='none', edgecolor='k', linewidth=2) <br>
			&nbsp;&nbsp;plt.gca().add_patch(circleOut) <br>
			&nbsp;&nbsp;circleIn = matplotlib.patches.CirclePolygon(xy, radius=rIn, facecolor='none', edgecolor='k', linewidth=1) <br>
			&nbsp;&nbsp;plt.gca().add_patch(circleIn) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Overlay pointer <br>
			&nbsp;&nbsp;poly = Polygon([[x1-inset,(y1+2*rOut)*1.1], [x1+extra*.5,y1-extra], [x1-inset,y1+inset-extra], [x1-2*inset-extra*.5,y1-extra]],facecolor='white',edgecolor='k',linewidth=1) <br>
			&nbsp;&nbsp;plt.gca().add_patch(poly) <br>
			&nbsp;&nbsp; <br>
			&nbsp;&nbsp;# Add text <br>
			&nbsp;&nbsp;text(x1-inset,y1+inset,'N' , <br>
			&nbsp;&nbsp;verticalalignment='center', horizontalalignment='center', fontname='Times New Roman', fontsize=12, color= 'k', fontweight='heavy')</p>

			<p>First off, I extend the Basemap module/class* with some added functionality so that my maps have legends.</p>
			<p class="cmd">class Basemap2(Basemap):</p>

			<p>First off, I extend the Basemap module/class* with some added functionality so that my maps have legends.</p>
			<p class="cmd">
&nbsp;&nbsp;&nbsp;def drawscale(self,length, yoffset=None): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""draw a simple map scale from x1,y to x2,y in map projection  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coordinates, label it with actual distance in miles"""  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Define dimensions <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1,y1,x2,y,extra = 0.03*map.xmax, 0.03*map.xmax, 0.03*map.xmax+length, 0.05*map.xmax, 0.01*map.xmax <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Call rectangle function for bounding box <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawRect(x1-extra,y1-extra,length+2*extra+1300,y1+2*extra, 'k', 1) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get info for scale bar <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yoffset = 0.01*map.ymax <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lon1,lat1 = self(x1,y,inverse=True)  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lon2,lat2 = self(x2,y,inverse=True)  <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert to map projection units <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gc = pyproj.Geod(a=self.rmajor,b=self.rminor)  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# This gets the distance on a level plane (inv), to get distance on the plane, use sqrt() <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;az12,az21,dist = gc.inv(lon1,lat1,lon2,lat2) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# These are the pieces of the scale bar <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x1,x2],[y,y],linewidth=1,color='k')  <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Vertical ticks <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x1,x1],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x1+length/6.0,x1+length/6.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x1+length/3.0,x1+length/3.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x1+2*length/3.0,x1+2*+length/3.0],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.plot([x2,x2],[y-yoffset,y+yoffset],linewidth=1,color='k')  <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Label after converting to miles <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 0 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(x1,y-yoffset-0.5*extra,'%d' % (dist*0*0.621371,), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 0.5 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(x1+length/6.0,y-yoffset-0.5*extra,'%g' % (round(dist/6/1000.*0.621371,1),), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(x1+length/3.0,y-yoffset-0.5*extra,'%d' % (dist/3/1000.*0.621371,), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(x1+length*2/3.0,y-yoffset-0.5*extra,'%d' % (dist*2/3/1000.*0.621371,), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='center',fontsize=9, color= 'k', fontweight='normal')  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 3 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(x1-200+length,y-yoffset-0.5*extra,'%d miles' % (dist/1000.*0.621371,), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verticalalignment='top', horizontalalignment='left',fontsize=9, color= 'k', fontweight='normal')</p>
				
				<p>This may look like a lot but it is mostly pretty simple stuff. The dimensions are scaled to the Basemap object we will call later. We call the rectangle function to get a box for the legend. The actual scale bar is set within the box using some info scaled from the map object. One key piece is that we convert from the Lat Long coordinates to the EPSG projection selected when we call the Basemap object later. We then get distances for the scale bar using that conversion. From there, we plot the scale bar with lines using the scaled info we have compiled. Then we label the tick marks on the scale bar and we have a scale bar!</p>

				<p class="cmd">
				def drawLegend(self,y1, yoffset=None):<br>
					# Define dimensions <br>
					x1 = 0.03*map.xmax <br>
					extra = 0.01*map.xmax <br>
					 <br>
					# Make a list of items <br>
					Items = ['LANL Boundary', 'Quotient <= 1', 'Quotient > 1'] <br>
					Markers = ['rectangle', 'lime', 'r'] <br>
					markerColor = ['k', 'orangered', 'lime'] <br>
					 <br>
					# Define height and width <br>
					vertLineSpace = 1000 <br>
					vertSpace = vertLineSpace*len(Items)+100 <br>
					horSpace = max([len(item) for item in Items])*550 <br>
					symbolSpace = 1500 <br>
					 <br>
					# Call rectangle function for bounding box <br>
					drawRect(x1-extra,y1,horSpace,vertSpace, 'k',1) <br>
					 <br>
					# Populate legend <br>
					j = 0 <br>
					for item in Items: <br>
						# Write text <br>
						text(x1+symbolSpace,y1+0.75*vertLineSpace+j*vertLineSpace, item, <br>
						verticalalignment='top', horizontalalignment='left',fontsize=11, color= 'k', fontweight='normal')  <br>
						 <br>
						# Draw symbols <br>
						if Markers[j] == 'rectangle': <br>
							drawRect(x1+0.25*symbolSpace,y1+0.25*vertLineSpace+j*vertLineSpace,0.5*symbolSpace, 0.5*vertLineSpace, markerColor[j],1.5) <br>
						else: <br>
							map.plot(x1+0.5*symbolSpace,y1+0.5*vertLineSpace+j*vertLineSpace,  <br>
							marker='o', color = Markers[j], markersize=5, markeredgewidth=1) <br>
						j = j + 1 <br>
				</p>

				<p>This function draws the plot legend. First the dimensions are defined. Again this is relative to the Basemap object. A list of the objects to display is defined by the user. The markers for those items are defined in another list and the color of the markers is defined in a third list. Then the height and width are defined by scaling to the size of the Items list. The rectangle function is called to create a bounding box and then the three lists are looped through to write the text and draw the symbols. Next we have one more function for creating a north arrow.</p>

				<p class="cmd">
	def northArrow(self): <br>
		# Define dimensions <br>
		x1,y1 = 0.97*map.xmax, 0.03*map.xmax <br>
		x,y,extra = 3000, 4000, 0.01*map.xmax <br>
		inset = 600 <br>
		rOut = 800 <br>
		rIn = 650 <br>
		xy = (x1-inset,y1+inset) <br>
		 <br>
		# Make circles <br>
		circleOut = matplotlib.patches.CirclePolygon(xy, radius=rOut, facecolor='none', edgecolor='k', linewidth=2) <br>
		plt.gca().add_patch(circleOut) <br>
		circleIn = matplotlib.patches.CirclePolygon(xy, radius=rIn, facecolor='none', edgecolor='k', linewidth=1) <br>
		plt.gca().add_patch(circleIn) <br>
		 <br>
		# Overlay pointer <br>
		poly = Polygon([[x1-inset,(y1+2*rOut)*1.1], [x1+extra*.5,y1-extra], [x1-inset,y1+inset-extra], [x1-2*inset-extra*.5,y1-extra]],facecolor='white',edgecolor='k',linewidth=1) <br>
		plt.gca().add_patch(poly) <br>
		 <br>
		# Add text <br>
		text(x1-inset,y1+inset,'N' , <br>
		verticalalignment='center', horizontalalignment='center', fontname='Times New Roman', fontsize=12, color= 'k', fontweight='heavy')  <br>
				</p>

				<p>Again, this is fairly simple plotting stuff so I will not go into it too deep. This is what I consider to be an eloquent looking north arrow but feel free to use whatever you would like. That concludes our functions so we are ready to get to the mapping!</p>
			
			<li>File Structure</li><br>

				<p>Now for the good stuff. Sorry there was so much setup but it will make the rest go pretty quickly. I like to write scripts that run in any place and create their own folders if needed. For that, we have to do some work with path and make sure that your file structure is correct. The image below shows how your should set up your file structure. The .py file should obviously go in the Python folder. 
				Download this <a href="">static</a> file and move it into the Static Files folder. These are the files that will be the same on each map. 
				Then download these <a href="">dynamic</a> data files and move them in the Data folder.</p>

				<img class="files" src="images\FilesStart.png" alt="FilesStart" height="100", width="300">				

				<p>With that said, let's jump right into the code.</p>

				<p class="cmd">
# Define path <br>
path = os.path.abspath(os.path.dirname(__file__)) <br>
# Shorten path to one folder up <br>
path = path[:find_last(path,os.sep)] <br>
 <br>
# # Get list of files to map <br>
# Create array to store names <br>
Files = [] <br>
for file in glob.glob(path+os.sep+'Data'+os.sep+'*.shp'): <br>
	Files.append(file)</p>

				<p>Here we get the .py file's path and use it to find the other files to map. Go ahead and try for yourself. You should have something similar to this.</p>
				<p class="cmd">>>>path<br>'C:\\Tools\\Basemap Mapper' <br>
					>>>Files<br>['C:\\Tools\\Basemap Mapper'\\*.shp', <br>'C:\\Tools\\Basemap Mapper'\\*.shp', <br>'C:\\Tools\\Basemap Mapper'\\*.shp']</p>

				<p>It's unlikely that your file name will print out so cleanly but you should have *3 files. You can check the length to be sure. That should have us ready to start the actual mapping now!</p>



			<li>Mapping</li><br>
	</ol>

</body>
</html>